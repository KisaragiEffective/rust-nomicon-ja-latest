<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>アロケーティング</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">はじめに</a></li><li class="chapter-item expanded "><a href="meet-safe-and-unsafe.html"><strong aria-hidden="true">1.</strong> 安全と危険のご紹介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safe-unsafe-meaning.html"><strong aria-hidden="true">1.1.</strong> 安全と危険の相互作用</a></li><li class="chapter-item expanded "><a href="working-with-unsafe.html"><strong aria-hidden="true">1.2.</strong> Unsafe と連携する</a></li></ol></li><li class="chapter-item expanded "><a href="data.html"><strong aria-hidden="true">2.</strong> データレイアウト</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="repr-rust.html"><strong aria-hidden="true">2.1.</strong> repr(Rust)</a></li><li class="chapter-item expanded "><a href="exotic-sizes.html"><strong aria-hidden="true">2.2.</strong> 奇妙なサイズの型</a></li><li class="chapter-item expanded "><a href="other-reprs.html"><strong aria-hidden="true">2.3.</strong> 代替メモリレイアウト</a></li></ol></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">3.</strong> 所有権とライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.1.</strong> リファレンス</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">3.2.</strong> ライフタイム</a></li><li class="chapter-item expanded "><a href="lifetime-mismatch.html"><strong aria-hidden="true">3.3.</strong> ライフタイムシステムの限界</a></li><li class="chapter-item expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">3.4.</strong> ライフタイムの省略</a></li><li class="chapter-item expanded "><a href="unbounded-lifetimes.html"><strong aria-hidden="true">3.5.</strong> 無制限のライフタイム</a></li><li class="chapter-item expanded "><a href="hrtb.html"><strong aria-hidden="true">3.6.</strong> 高階トレイト境界</a></li><li class="chapter-item expanded "><a href="subtyping.html"><strong aria-hidden="true">3.7.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="dropck.html"><strong aria-hidden="true">3.8.</strong> Drop Check</a></li><li class="chapter-item expanded "><a href="phantom-data.html"><strong aria-hidden="true">3.9.</strong> PhantomData</a></li><li class="chapter-item expanded "><a href="borrow-splitting.html"><strong aria-hidden="true">3.10.</strong> 借用の分割</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> 型変換</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="coercions.html"><strong aria-hidden="true">4.1.</strong> 型強制</a></li><li class="chapter-item expanded "><a href="dot-operator.html"><strong aria-hidden="true">4.2.</strong> ドットオペレータ</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">4.3.</strong> キャスト</a></li><li class="chapter-item expanded "><a href="transmutes.html"><strong aria-hidden="true">4.4.</strong> トランスミュート</a></li></ol></li><li class="chapter-item expanded "><a href="uninitialized.html"><strong aria-hidden="true">5.</strong> 初期化されないメモリ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="checked-uninit.html"><strong aria-hidden="true">5.1.</strong> チェックされるメモリ</a></li><li class="chapter-item expanded "><a href="drop-flags.html"><strong aria-hidden="true">5.2.</strong> ドロップフラグ</a></li><li class="chapter-item expanded "><a href="unchecked-uninit.html"><strong aria-hidden="true">5.3.</strong> チェックされないメモリ</a></li></ol></li><li class="chapter-item expanded "><a href="obrm.html"><strong aria-hidden="true">6.</strong> 所有権に基づいたリソース管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="constructors.html"><strong aria-hidden="true">6.1.</strong> コンストラクタ</a></li><li class="chapter-item expanded "><a href="destructors.html"><strong aria-hidden="true">6.2.</strong> デストラクタ</a></li><li class="chapter-item expanded "><a href="leaking.html"><strong aria-hidden="true">6.3.</strong> リーク</a></li></ol></li><li class="chapter-item expanded "><a href="unwinding.html"><strong aria-hidden="true">7.</strong> 巻き戻し</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exception-safety.html"><strong aria-hidden="true">7.1.</strong> 例外安全性</a></li><li class="chapter-item expanded "><a href="poisoning.html"><strong aria-hidden="true">7.2.</strong> ポイゾニング</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">8.</strong> 並行性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="races.html"><strong aria-hidden="true">8.1.</strong> 競合</a></li><li class="chapter-item expanded "><a href="send-and-sync.html"><strong aria-hidden="true">8.2.</strong> Send and Sync</a></li><li class="chapter-item expanded "><a href="atomics.html"><strong aria-hidden="true">8.3.</strong> Atomics</a></li></ol></li><li class="chapter-item expanded "><a href="vec.html"><strong aria-hidden="true">9.</strong> Vec の実装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vec-layout.html"><strong aria-hidden="true">9.1.</strong> レイアウト</a></li><li class="chapter-item expanded "><a href="vec-alloc.html" class="active"><strong aria-hidden="true">9.2.</strong> アロケーティング</a></li><li class="chapter-item expanded "><a href="vec-push-pop.html"><strong aria-hidden="true">9.3.</strong> プッシュとポップ</a></li><li class="chapter-item expanded "><a href="vec-dealloc.html"><strong aria-hidden="true">9.4.</strong> デアロケーティング</a></li><li class="chapter-item expanded "><a href="vec-deref.html"><strong aria-hidden="true">9.5.</strong> 参照外し</a></li><li class="chapter-item expanded "><a href="vec-insert-remove.html"><strong aria-hidden="true">9.6.</strong> 挿入と削除</a></li><li class="chapter-item expanded "><a href="vec-into-iter.html"><strong aria-hidden="true">9.7.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="vec-raw.html"><strong aria-hidden="true">9.8.</strong> RawVec</a></li><li class="chapter-item expanded "><a href="vec-drain.html"><strong aria-hidden="true">9.9.</strong> Drain</a></li><li class="chapter-item expanded "><a href="vec-zsts.html"><strong aria-hidden="true">9.10.</strong> Handling Zero-Sized Types</a></li><li class="chapter-item expanded "><a href="vec-final.html"><strong aria-hidden="true">9.11.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="arc-and-mutex.html"><strong aria-hidden="true">10.</strong> Arc と Mutex の実装</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Allocating Memory
-->
<h1><a class="header" href="#メモリのアロケーティング" id="メモリのアロケーティング">メモリのアロケーティング</a></h1>
<!--
Using Unique throws a wrench in an important feature of Vec (and indeed all of
the std collections): an empty Vec doesn't actually allocate at all. So if we
can't allocate, but also can't put a null pointer in `ptr`, what do we do in
`Vec::new`? Well, we just put some other garbage in there!
-->
<p>Unique を使用することで、 Vec の重要な機能に関して (そして実に std の全ての
コレクションにおいて) 問題が発生します。すなわち、空の Vec は実際に、
何もアロケートしていないのです。ですからもしアロケート出来ないだけではなく、
<code>ptr</code> にヌルポインタを代入出来ないとしたら、 <code>Vec::new</code> で何をすれば
いいのでしょうか? そうだ、単純にそこに何か他のゴミを突っ込みましょう!</p>
<!--
This is perfectly fine because we already have `cap == 0` as our sentinel for no
allocation. We don't even need to handle it specially in almost any code because
we usually need to check if `cap > len` or `len > 0` anyway. The traditional
Rust value to put here is `0x01`. The standard library actually exposes this
as `alloc::heap::EMPTY`. There are quite a few places where we'll
want to use `heap::EMPTY` because there's no real allocation to talk about but
`null` would make the compiler do bad things.
-->
<p>これは全く問題ありません。なぜなら、 <code>cap == 0</code> が既に、アロケーションが
ないことを示す番兵となっているからです。もはやこれを特別扱いする必要も
ありません。なぜならほとんどすべてのコードで、結局は <code>cap &gt; len</code> か <code>len &gt; 0</code> を
通常確かめる必要があるからです。伝統的に Rust では、 <code>0x01</code> を突っ込んでいます。
標準ライブラリでは実際にこれを <code>alloc::heap::EMPTY</code> として公開しています。
<code>null</code> を使ってしまうとコンパイラが悪さをしてしまうけれども、実際の
アロケーションが存在しないために <code>heap::EMPTY</code> を使用したい箇所がかなり
多く存在します。</p>
<!--
All of the `heap` API is totally unstable under the `heap_api` feature, though.
We could trivially define `heap::EMPTY` ourselves, but we'll want the rest of
the `heap` API anyway, so let's just get that dependency over with.
-->
<p>それでも全ての <code>heap</code> の API は、 <code>heap_api</code> フィーチャの下で、
全くアンステーブルです。自ら <code>heap::EMPTY</code> を定義してしまうことも
出来るでしょうが、結局 <code>heap</code> の他の API を使いたくなるため、単にその API を
依存関係に追加しましょう。</p>
<!--
So:
-->
<p>こうなります:</p>
<pre><code class="language-rust ignore">#![feature(alloc, heap_api)]

use std::mem;

use alloc::heap::EMPTY;

impl&lt;T&gt; Vec&lt;T&gt; {
    fn new() -&gt; Self {
        // まだ ZST を扱う準備が出来ていません
        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;We're not ready to handle ZSTs&quot;);
        unsafe {
            // EMPTY を欲しい実際のポインタ型にキャストする必要があります。
            // 推論してもらいましょう。
            Vec { ptr: Unique::new(heap::EMPTY as *mut _), len: 0, cap: 0 }
        }
    }
}
</code></pre>
<!--
I slipped in that assert there because zero-sized types will require some
special handling throughout our code, and I want to defer the issue for now.
Without this assert, some of our early drafts will do some Very Bad Things.
-->
<p>コードの中に、assert を入れました。サイズが 0 の型は、コード全体において
何か特別な処理をする必要があり、この問題を今は後回しにしたいためです。
この assert がないと、コードの下書きにおいて、なにか非常にまずいことを
起こしてしまいます。</p>
<!--
Next we need to figure out what to actually do when we *do* want space. For
that, we'll need to use the rest of the heap APIs. These basically allow us to
talk directly to Rust's allocator (jemalloc by default).
-->
<p>次に、<em>本当に</em>スペースがほしいときに、実際に何をすればいいかを考える
必要があります。そのためには、 heap の他の API を使用する必要があります。
基本的にこれらによって、 Rust のアロケータ (デフォルトでは jemalloc) と
対話できるようになります。</p>
<!--
We'll also need a way to handle out-of-memory (OOM) conditions. The standard
library calls the `abort` intrinsic, which just calls an illegal instruction to
crash the whole program. The reason we abort and don't panic is because
unwinding can cause allocations to happen, and that seems like a bad thing to do
when your allocator just came back with "hey I don't have any more memory".
-->
<p>また、メモリ不足 (out-of-memory, OOM) の状態に対処する方法も必要です。
標準ライブラリでは、単に <code>abort</code> intrinsic を呼びます。これは単純に
不正な命令を呼び出して、プログラムをクラッシュさせます。なぜパニックではなく
アボートさせるかというと、巻き戻しはアロケーションを起こす事があるため、
アロケータが &quot;なあ、もうメモリがないぜ&quot; と帰ってきたときに巻き戻しを行なうのは
まずいからです。</p>
<!--
Of course, this is a bit silly since most platforms don't actually run out of
memory in a conventional way. Your operating system will probably kill the
application by another means if you legitimately start using up all the memory.
The most likely way we'll trigger OOM is by just asking for ludicrous quantities
of memory at once (e.g. half the theoretical address space). As such it's
*probably* fine to panic and nothing bad will happen. Still, we're trying to be
like the standard library as much as possible, so we'll just kill the whole
program.
-->
<p>もちろん、通常ならほとんどのプラットフォームにおいて、実際にメモリ不足に
陥ることはないため、これはちょっと馬鹿げています。オペレーティングシステムは、
何らかの理由でアプリケーションが全てのメモリを使用しているなら、
そのアプリケーションを他の手段によって多分 kill するでしょう。
OOM になってしまう、もっともあり得る場合というのは単に、信じられないくらいの
メモリ量をいっぺんに確保しようとする場合です (例: 理論上のアドレス空間の半分) 。
ですからパニックしても<em>多分</em>問題なく、何も悪いことは起きません。それでも、
なるべく標準ライブラリに似せるため、ここでは単にプログラム全体を kill します。</p>
<!--
We said we don't want to use intrinsics, so doing exactly what `std` does is
out. Instead, we'll call `std::process::exit` with some random number.
-->
<p>intrinsic を使いたくないと述べました。ですので、 <code>std</code> で行なっていることと、
全く同じことをすることは出来ません。代わりに、 <code>std::process::exit</code> を
適当な値と共に呼び出します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn oom() {
    ::std::process::exit(-9999);
}
<span class="boring">}
</span></code></pre></pre>
<!--
Okay, now we can write growing. Roughly, we want to have this logic:
-->
<p>よし、これで Vec の伸長のコードを書くことが出来ます。欲しい
ロジックは大体以下のようなものです。</p>
<pre><code class="language-text">if cap == 0:
    allocate()
    cap = 1
else:
    reallocate()
    cap *= 2
</code></pre>
<!--
But Rust's only supported allocator API is so low level that we'll need to do a
fair bit of extra work. We also need to guard against some special
conditions that can occur with really large allocations or empty allocations.
-->
<p>しかし、 Rust が唯一サポートしているアロケータ API は本当に低レベルな
ものですので、追加の作業がかなり必要です。また、本当に大きいアロケーションや、
空のアロケーションの際に起こる、特別な状況に対してガードする必要もあります。</p>
<!--
In particular, `ptr::offset` will cause us a lot of trouble, because it has
the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to
not have dealt with this instruction, here's the basic story with GEP: alias
analysis, alias analysis, alias analysis. It's super important to an optimizing
compiler to be able to reason about data dependencies and aliasing.
-->
<p>特に <code>ptr::offset</code> は、沢山の問題を引き起こします。なぜならこれは、 LLVM の、
GEP インバウンド命令のセマンティクスを持っているからです。もしあなたが
幸運にも、この命令に対処したことがない場合、こちらが GEP に関する
基本的な事柄です: エイリアス分析、エイリアス分析、エイリアス分析。
コンパイラが最適化をする際、データの依存関係や、エイリアシングを
推論できるということは、本当に重要なのです。</p>
<!--
As a simple example, consider the following fragment of code:
-->
<p>単純な例として、以下のコード片を考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = &amp;mut 0;
</span><span class="boring">let y = &amp;mut 0;
</span>*x *= 7;
*y *= 3;
<span class="boring">}
</span></code></pre></pre>
<!--
If the compiler can prove that `x` and `y` point to different locations in
memory, the two operations can in theory be executed in parallel (by e.g.
loading them into different registers and working on them independently).
However the compiler can't do this in general because if x and y point to
the same location in memory, the operations need to be done to the same value,
and they can't just be merged afterwards.
-->
<p>もしコンパイラが、 <code>x</code> と <code>y</code> がメモリ上の別の場所をそれぞれ指していると
証明できるのなら、理論的には、これらの 2 つの命令は並列に行なうことが
可能です (例: 異なるレジスタにロードして、個別に操作する) 。
しかしながら、コンパイラは一般的にこれをすることが出来ません。
なぜなら、 <code>x</code> と <code>y</code> がメモリ上の同一の場所を指しているのなら、操作を
同じ値に対して行なわなければならず、単に最後、統合することは不可能だからです。</p>
<!--
When you use GEP inbounds, you are specifically telling LLVM that the offsets
you're about to do are within the bounds of a single "allocated" entity. The
ultimate payoff being that LLVM can assume that if two pointers are known to
point to two disjoint objects, all the offsets of those pointers are *also*
known to not alias (because you won't just end up in some random place in
memory). LLVM is heavily optimized to work with GEP offsets, and inbounds
offsets are the best of all, so it's important that we use them as much as
possible.
-->
<p>GEP インバウンドを使用する際、実行しようとしているオフセットは、
単一の &quot;アロケートされた&quot; エンティティの境界内に収まると、 LLVM に
はっきりと伝えることになります。 LLVM を使うことによる究極の利点は、
2 つのポインタが異なるオブジェクトを指すと分かっている時、これらの
ポインタの全てのオフセット<em>も</em>、エイリアスではないということが
分かるということです (なぜならメモリ上のどこかランダムな場所を
指さないと分かっているからです) 。 LLVM は、 GEP オフセットを
扱うために激しく最適化されていて、インバウンドオフセットは
全ての中で最良のものです。ですからなるべくこれらを使うことが重要です。</p>
<!--
So that's what GEP's about, how can it cause us trouble?
-->
<p>これが、 GEP についてです。ではこれが、どのような問題を引き起こすのでしょうか?</p>
<!--
The first problem is that we index into arrays with unsigned integers, but
GEP (and as a consequence `ptr::offset`) takes a signed integer. This means
that half of the seemingly valid indices into an array will overflow GEP and
actually go in the wrong direction! As such we must limit all allocations to
`isize::MAX` elements. This actually means we only need to worry about
byte-sized objects, because e.g. `> isize::MAX` `u16`s will truly exhaust all of
the system's memory. However in order to avoid subtle corner cases where someone
reinterprets some array of `< isize::MAX` objects as bytes, std limits all
allocations to `isize::MAX` bytes.
-->
<p>第一に、配列のインデックス指定では符号なし整数を指定しますが、
GEP (そして結果として <code>ptr::offset</code> も) では符号付き整数を受け取ります。
これはつまり、配列のインデックス指定では有効であろう値の半分が、 GEP では
オーバーフローしてしまい、実際に間違った方向に進んでしまうのです! ですから
全てのアロケーションを <code>isize::MAX</code> 個の要素に制限しなければなりません。
これは実際には、バイトサイズのオブジェクトに関してのみ、心配する必要があります。
なぜなら、例えば <code>isize::MAX</code> 個以上の <code>u16</code> などでは、明らかにシステムのメモリを
使い果たしてしまうでしょう。しかし、何らかの、 <code>isize::MAX</code> 個以下のオブジェクトを
持つ配列をバイト群と再解釈するような、微妙なコーナーケースを避けるため、
std では全てのアロケーションを <code>isize::MAX</code> バイトに制限しています。</p>
<!--
On all 64-bit targets that Rust currently supports we're artificially limited
to significantly less than all 64 bits of the address space (modern x64
platforms only expose 48-bit addressing), so we can rely on just running out of
memory first. However on 32-bit targets, particularly those with extensions to
use more of the address space (PAE x86 or x32), it's theoretically possible to
successfully allocate more than `isize::MAX` bytes of memory.
-->
<p>Rust が現在サポートしている 64 ビットのターゲットでは、 恣意的に、 64 ビットの
アドレス空間全体よりも遥かに少なく制限されています (現代の x64 プラットフォームでは、
48 ビットのアドレスしか使用可能ではありません) 。ですから単純に、最初にメモリ不足に
なると考えて良いです。しかし 32 ビットのターゲットでは、特に追加のアドレス空間
を使用する拡張に対して (PAE x86 や x32) 、理論的には <code>isize::MAX</code> バイト以上の
メモリをアロケートしてしまうことが可能です。</p>
<!--
However since this is a tutorial, we're not going to be particularly optimal
here, and just unconditionally check, rather than use clever platform-specific
`cfg`s.
-->
<p>しかしながら、これはチュートリアルですので、ここではベストを尽くしません。
単に、プラットフォーム特有の <code>cfg</code> 等を使用するのではなく、状況に関わりなく
チェックします。</p>
<!--
The other corner-case we need to worry about is empty allocations. There will
be two kinds of empty allocations we need to worry about: `cap = 0` for all T,
and `cap > 0` for zero-sized types.
-->
<p>心配しなければならない他のコーナーケースは、空のアロケーションです。
空のアロケーションには 2 種類あります。 全ての T における <code>cap = 0</code> と、
サイズが 0 の型における <code>cap &gt; 0</code> です。</p>
<!--
These cases are tricky because they come
down to what LLVM means by "allocated". LLVM's notion of an
allocation is significantly more abstract than how we usually use it. Because
LLVM needs to work with different languages' semantics and custom allocators,
it can't really intimately understand allocation. Instead, the main idea behind
allocation is "doesn't overlap with other stuff". That is, heap allocations,
stack allocations, and globals don't randomly overlap. Yep, it's about alias
analysis. As such, Rust can technically play a bit fast and loose with the notion of
an allocation as long as it's *consistent*.
-->
<p>これらは結局、 LLVM が意味する &quot;アロケートされた&quot; 状態ですので、扱いにくいです。
LLVM におけるアロケーションの概念は、我々が普段使う概念よりも遥かに抽象的です。
LLVM は異なる言語のセマンティクスや、カスタムアロケータを扱う必要があるため、
アロケーションに深入り出来ないのです。その代わり、アロケーションの
背後にある主要な考えは &quot;他のものと重ならない&quot; という事です。つまり、
ヒープアロケーションやスタックアロケーション、そしてグローバルな
アロケーションは、ランダムに重なることはありません。ええ、これはエイリアス分析
についてです。ですから、 Rust は<em>一貫性</em>を保つ限り、アロケーションの概念に関しては
技術的に、ちょっと高速に、ちょっと緩く、行なうことが出来ます。</p>
<!--
Getting back to the empty allocation case, there are a couple of places where
we want to offset by 0 as a consequence of generic code. The question is then:
is it consistent to do so? For zero-sized types, we have concluded that it is
indeed consistent to do a GEP inbounds offset by an arbitrary number of
elements. This is a runtime no-op because every element takes up no space,
and it's fine to pretend that there's infinite zero-sized types allocated
at `0x01`. No allocator will ever allocate that address, because they won't
allocate `0x00` and they generally allocate to some minimal alignment higher
than a byte. Also generally the whole first page of memory is
protected from being allocated anyway (a whole 4k, on many platforms).
-->
<p>空のアロケーションの場合について戻りましょう。ジェネリックなコードの結果、 0 の
オフセットが欲しい場合がいくつかあります。そうすると問題はこうなります。すなわち、
これを行なうことは、一貫性があるのでしょうか? 例えばサイズが 0 の型の場合、
任意の要素数による GEP インバウンドオフセットを行なうことは、実に一貫性が
あると結論付けました。これは実行時には no-op です。なぜなら、全ての要素は
スペースを消費せず、そして <code>0x01</code> に無限の数の、サイズが 0 の型がアロケート
されているとしても問題ないからです。どのアロケータも、絶対にそのアドレスには
アロケートしません。なぜなら、アロケータは <code>0x00</code> にはアロケートせず、
一般的にバイト以上のある最小のアラインメントにアロケートするからです。
また一般的には、メモリの最初のページ全体は、アロケートされることに対し
結局保護されています (多くのプロットフォームでは 4k 全体) 。</p>
<!--
However what about for positive-sized types? That one's a bit trickier. In
principle, you can argue that offsetting by 0 gives LLVM no information: either
there's an element before the address or after it, but it can't know which.
However we've chosen to conservatively assume that it may do bad things. As
such we will guard against this case explicitly.
-->
<p>しかしながら、サイズが正の型についてはどうでしょうか? これはちょっと
トリッキーです。一般には、 0 のオフセットでは LLVM には何の情報も
行き渡らないと論ずる事が出来ます。すなわち、アドレスの前か後ろかの
どちらかに要素があるけれども、どっちなのかはわからないということです。
しかし、これによって悪いことが起きると保守的に見なすことを選びました。
ですからこれらの場合に対しては、明示的にガードします。</p>
<!--
*Phew*
-->
<p><em>ふー</em></p>
<!--
Ok with all the nonsense out of the way, let's actually allocate some memory:
-->
<p>よし、ナンセンスな物を退けましたので、実際にメモリをアロケートしてみましょう。</p>
<pre><code class="language-rust ignore">fn grow(&amp;mut self) {
    // これは本当に繊細なので、全部アンセーフにしましょう
    unsafe {
        // 現在の API では、大きさとアラインメントを手動で指定する必要があります。
        let align = mem::align_of::&lt;T&gt;();
        let elem_size = mem::size_of::&lt;T&gt;();

        let (new_cap, ptr) = if self.cap == 0 {
            let ptr = heap::allocate(elem_size, align);
            (1, ptr)
        } else {
            // 不変条件ですので、 `self.cap &lt; isize::MAX` と見なすことが出来ます。
            // ですからチェックする必要はありません。
            let new_cap = self.cap * 2;
            // 同様に、前にアロケートしたのでオーバーフローすることはありません
            let old_num_bytes = self.cap * elem_size;

            // 実際のキャパシティの大きさに関わらず、新しいアロケーションが
            // `isize::MAX` を超過しないか確認します。これは、必要なチェックである、
            // `new_cap &lt;= isize::MAX` と `new_num_bytes &lt;= usize::MAX` を
            // 組み合わせています。もっとも、例えば 32ビットプラットフォーム上では、
            // i16 の単一の Vec で、アドレス空間の 2/3 をアロケートすることは
            // できなくなっていますが。
            // Alas, poor Yorick -- I knew him, Horatio.
            // (訳注: シェイクスピアに登場する、ハムレットのセリフです)
            assert!(old_num_bytes &lt;= (::std::isize::MAX as usize) / 2,
                    &quot;capacity overflow&quot;);

            let new_num_bytes = old_num_bytes * 2;
            let ptr = heap::reallocate(*self.ptr as *mut _,
                                        old_num_bytes,
                                        new_num_bytes,
                                        align);
            (new_cap, ptr)
        };

        // もしアロケートや、リアロケートに失敗すると、 `null` が返ってきます
        if ptr.is_null() { oom(); }

        self.ptr = Unique::new(ptr as *mut _);
        self.cap = new_cap;
    }
}
</code></pre>
<!--
Nothing particularly tricky here. Just computing sizes and alignments and doing
some careful multiplication checks.
-->
<p>ここでは特にトリッキーなことはしていません。単にサイズとアラインメントを計算し、
掛け算を注意深くチェックしています。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="vec-layout.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="vec-push-pop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="vec-layout.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="vec-push-pop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
